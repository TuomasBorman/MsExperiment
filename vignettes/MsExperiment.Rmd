---
title: "Managing mass spectrometry experiments"
output:
    BiocStyle::html_document:
        toc_float: true
vignette: >
    %\VignetteIndexEntry{Managing mass spectrometry experiments}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
    %\VignettePackage{MsExperiment}
    %\VignetteDepends{BiocStyle,rpx,Spectra}
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Package**: `r Biocpkg("MsExperiment")`<br />
**Authors**: `r packageDescription("MsExperiment")[["Author"]] `<br />
**Last modified:** `r file.info("MsExperiment.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r, echo = FALSE, message = FALSE}
library(MsExperiment)
library(Spectra)
library(BiocStyle)
```

# Introduction

The goal of the `MsExperiment` package is the store and handle all
data related to a mass spectrometry experiment. In this vignette, we
will describe how to create a `MsExperiment` object and populate it
with various types of data.

```{r}
library("MsExperiment")
```

# Getting data

We will use a small subset of the
[PXD022816](https://www.ebi.ac.uk/pride/archive/projects/PXD022816)
project ([Morgenstern et
al. (2020)](https://doi.org/10.1021/acs.jproteome.0c00956)). The
acquisitions correspond to a Pierce Thermo HeLa digestion standard,
diluted to 50ng/uL with 97:3 + 0.1% formic acid, and acquired on a
QExactive instrument.

Below, we use the `r Biocpkg("rpx")` package to access the project
from the PRIDE repository, and download files of interest. Note that
these will automatically be cached in the `rpx` packages' cache
directory.

```{r}
library("rpx")
px <- PXDataset("PXD022816")
px
pxfiles(px)
```

The project provides the vendor raw files, the converted mzML files as
well as the identification mzid files. Let's download fractions 1 and
2 of the mzML files.

If you run these commands interactively and it's the first time you
use `pxget()`, you will be asked to create the `rpx` cache directory -
you can safelfy answer *yes*. The files will then be downloaded. Next
time you want to get the same files, they will be loaded automatically
from cache.

```{r}
(i <- grep(".+0[12].+mzML$", pxfiles(px), value = TRUE))
fls <- pxget(px, i)
fls
```

# Mass spectrometry experiment

Let's start by creating an empty `MsExperiment` object that we will
populate with different pieces of data as we proceed with the analysis
of our data.

```{r}
msexp <- MsExperiment()
msexp
```

## Experiment files

Let's now start with our MS experiment management by saving the
relevant files in a dedicated `MsExperimentFiles` object. In addition
to the mzML files, let's also assume we have the human proteomics
fasta file ready. Later, when loading the raw data into R, we will
refer directly to the files in this `MsExperimentFiles` object.

```{r}
msfls <- MsExperimentFiles(mzmls = fls,
                           fasta = "homo_sapiens.fasta")
msfls
```

Let's add these files to the main experiment management object:

```{r}
experimentFiles(msexp) <- msfls
msexp
```

## Experimental design

The `colData` slot is used to describe the overall experimental design
of the experiment. It can be used to link samples to the files that
are part of the experiment. There can be a one-to-one link between a
sample and a file, such as for example in label-free approaches, or
one-to-many, in labelled multiplexed approaches.

Here, we are simply going to use the `colData` slot to match the files
to their respective fractions:

```{r}
sampleData(msexp) <- DataFrame(mzmls = basename(experimentFiles(msexp)[["mzmls"]]),
                               fractions = 1:2)
sampleData(msexp)
```

## Raw data

We can now create a `Spectra` object containing the raw data stored in
the mzML files. If you are not familiar with the `Spectra` object,
please refer to the [package
vignettes](https://rformassspectrometry.github.io/Spectra/articles/Spectra.html).

```{r}
sp <- Spectra(experimentFiles(msexp)[["mzmls"]])
sp
```

We can now add this object to the main experiment management object:

```{r}
spectra(msexp) <- sp
msexp
```

## Third party applications

Let's now assume we want to search the spectra in our mzML files
against the `homo_sapiens.fasta` file. To do so, we would like to use
a search engine such as MSGF+, that is run using the command line and
generates mzid files.

The command to run MSGF+ would look like this (see the [manual
page](https://msgfplus.github.io/msgfplus/MSGFPlus.html) for details):

```
java -jar /path/to/MSGFPlus.jar \
     -s input.mzML \
     -o output.mzid
     -d proteins.fasta \
     -t 20ppm \ ## precursor mass tolerance
     -tda 1 \   ## search decoy database
     -m 0 \     ## fragmentation method as written in the spectrum or CID if no info
     -int 1     ## Orbitrap/FTICR/Lumos
```

We can easily build such a command for each of our input file:

```{r}
mzids <- sub("mzML", "mzid", basename(experimentFiles(msexp)[["mzmls"]]))
paste0("java -jar /path/to/MSGFPlus.jar",
       " -s ", experimentFiles(msexp)[["mzmls"]],
       " -o ", mzids,
       " -d ", experimentFiles(msexp)[["fasta"]],
       " -t 20ppm",
       " -m 0",
       " int 1")
```

Here, for the sake of time and portability, we will not actually run
MSGF+, but a simple shell script that will generate mzid files in a
temporary R directory.


```{r}
(output <- file.path(tempdir(), mzids))
cmd <- paste("touch", output)
cmd
```

The `cmd` variable holds the two commands to be run on the command
line that will generate the new files. We can run each of these
commands with the `system()` function.

```{r}
sapply(cmd, system)
```

Below, we add the names of the newly created files to our experiment:

```{r}
experimentFiles(msexp)[["mzids"]] <- mzids
experimentFiles(msexp)
msexp
```

We can also decide to store the commands that were used to generate
the mzid files in the experiment's metadata slot. Here, we use the
convention to name that metadata item `"mzmls_to_mzids"` to document
to input and output of these commands.

```{r}
metadata(msexp)[["mzmls_to_mzids"]] <- cmd
metadata(msexp)
```

Finally, the `existMsExperimentFiles()` can be used at any time to
check which of files that are associated with an experiment actually
exist:

```{r}
existMsExperimentFiles(msexp)
```

# Conclusions

The `MsExperiment` object has been used to store files and data
pertaining to a mass spectrometry experiment. It is now possible to
save that object and reload it later to recover all data and metadata.


```{r}
saveRDS(msexp, "msexp.rda")
rm(list = ls())
```

```{r}
msexp <- readRDS("msexp.rda")
msexp
experimentFiles(msexp)
```

We can access the raw data as long as the mzML files that were used to
generate it still exist in their original location, which is the case
here as they were saved in the `rpx` cache directory.

```{r}
sp <- spectra(msexp)
sp
plotSpectra(sp[1000])
```

# Linking experimental data to samples

For some experiments and data analyses an explicit link between data, data files
and respective samples is required. This enables an easy (and error-free)
subsetting and re-ordering by sample as well as coloring and labeling of the
data depending on e.g. the sample or its condition.

Below we generate an `MsExperiment` object for a simple experiment consisting of
a single sample measured in two different injections to the same LC-MS setup.

```{r}
mse <- MsExperiment()
sd <- DataFrame(sample_id = c("QC1", "QC2"),
                sample_name = c("QC Pool", "QC Pool"),
                injection_idx = c(1, 3))
sampleData(mse) <- sd
```

We next add mzML files to the experiment for the sample that was measured. These
are available within the `msdata` R package. We add also an additional
*annotation* file `"internal_standards.txt"` to the experiment, which could be
e.g. a file with m/z and retention times of internal standards added to the
sample (note that such files don't necessarily have to exist).

```{r}
fls <- dir(system.file("sciex", package = "msdata"), full.names = TRUE)
basename(fls)

experimentFiles(mse) <- MsExperimentFiles(
    mzML_files = fls,
    annotations = "internal_standards.txt")
```

Next we load the MS data from the mzML files as a `Spectra` object and add them
to the experiment (see the vignette of the `r BiocStyle::Biocpkg("Spectra")` for
details on import and representation of MS data).

```{r}
sps <- Spectra(fls, backend = MsBackendMzR())
spectra(mse) <- sps
mse
```

At this stage we have thus sample annotations and MS data in our object, but no
explicit relationships between them. We next use the `linkSpectraData` function
to establish and define such relationships. First we link the experimental files
to the samples:

```{r}
mse <- linkSampleData(mse, with = "experimentFiles.mzML_file",
                      fromIndex = c(1, 2), toIndex = c(1, 2))
```

With parameter `with` we define which element in the object we want to link
samples. By using `"experimentFiles.mzML_file"` we link the *attribute* (or
*element*) called `"mzML_file"` in the object's `"experimentFiles"` slot to
samples. The way how elements are named in an `MsExperiment` is similar to SQL:
the first part of the name (before the `"."`) defines the slot in the object
(equivalent to a database's table), the second part (after the `"."`) is the
name of the element in that slot (equivalent to the *field* or database table
column in SQL). `"experimentFiles.mzML_file` thus refers to the element named
`"mzML_file"` within `experimentFiles(mse)`. `fromIndex` and `toIndex` allows to
define which rows in `sampleData` (`fromIndex`) should be linked to which
elements in `with` (`toIndex`). In the example above we linked thus the first
sample (row) in `sampleData` to the first element in
`experimentFiles(mse)$mzML_file` and the second sample to the second element.

Below we establish a second link between each sample and the *annotation*
file `"internal_standards.txt"` in `experimentFiles(mse)$standards`:

```{r}
mse <- linkSampleData(mse, with = "experimentFiles.annotations",
                      fromIndex = c(1, 2), toIndex = c(1, 1))
```

It is thus also possible to link different samples to the same element. We next
link the spectra in the object to the individual samples. To simplify this, we
add also the mzML file name (with the full patch) to the object's `sampleData`
and describe the link then in a SQL-like join syntax.

```{r}
sampleData(mse)$raw_file <- normalizePath(fls)
mse <- linkSampleData(mse, with = "sampleData.raw_file = spectra.dataOrigin")

mse
```

Internally, `linkSampleData` matched each sample based on column `"raw_file"` in
`sampleData` to spectra with a matching value in the `"dataOrigin"` spectra
variable. Alternatively, we could also provided the indices of the
sample-to-spectra assignment with `fromIndex` and `toIndex` as before.

The main advantage of these links is that any subsetting of the experiment by
sample will keep all the data consistent. To illustrate this we subset below the
experiment to the second sample.

```{r}
b <- mse[, 2]
b
```

The subsetted object contains now all data elements that are linked to this
second sample. But what happens for data elements that are not linked to any
sample? Below we add a `data.frame` as a `metadata` to the experiment and subset
the object again.

```{r}
metadata(mse)$other <- data.frame(sample_name = c("study_1", "POOL", "study_2"),
                                  index = 1:3)
b <- mse[, 2]
metadata(b)
```

By default, any element which is **not** linked to a sample is retained. We next
link each sample to the second row in this data frame and subset the data again
to the second sample.

```{r}
mse <- linkSampleData(mse, with = "metadata.other",
                      fromIndex = 1:2, toIndex = c(2, 2))
b <- mse[, 2]
metadata(b)
```

Subsetting thus retained only the row in the data frame for the linked
sample. Obviously it is also possible to subset to multiple samples, in
arbitrary order. Below we re-order our experiment.

```{r}
mse <- mse[, c(2, 1)]
sampleData(mse)
```

The sample order is thus reversed and also all other linked elements are
re-ordered accordingly, such as `"mzML_file"` in the object's `experimentFiles`.

```{r}
experimentFiles(mse)$mzML_file
```

It is however important to note, that subsetting will also *duplicate* elements
that are associated with multiple samples:

```{r}
experimentFiles(mse)$annotations
```

Thus, while we added a single *annotation* file to the data element
`"annotations"` in `experimentFiles`, after subsetting we ended up with two
identical files. This eventual duplication of *n:m* relationships between
samples to elements does however not affect data consistency. A sample will
always be linked to the correct value/element.


# Session information

```{r si}
sessionInfo()
```
